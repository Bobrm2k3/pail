import sqlite3 as sqliteimport sysimport string#definesBANNED = 0ADMIN = 1SUPREME_ADMIN = 2REQ_DOWNVOTES = 4class dbAccess(object):  def __init__(self, dbName):    self.db = sqlite.connect(dbName)    self.cur = self.db.cursor()      def __del__(self):    self.db.close()      # add ban/admin/s admin, will update the row if the nick is already in the database  # returns False is no change was made, True otherwise  def addUserlist(self, nick, newStatus, verified=False):    if newStatus not in [BANNED, ADMIN, SUPREME_ADMIN]:      print ">>User status(%s) not valid<<" % newStatus      return    nick = nick.lower()        self.cur.execute("SELECT Status FROM Userlist WHERE Nick=?", (nick,))    oldStatus = self.cur.fetchone()    if oldStatus == None:      self.cur.execute("INSERT INTO Userlist VALUES(?,?,?)", (nick, newStatus, int(verified),))    #can't downgrade someone's status    elif oldStatus[0] < newStatus:      self.cur.execute("UPDATE Userlist SET Status=? WHERE Nick=?", (newStatus, nick,))    else:      return False          self.db.commit()    return True    # del ban/admin, status is checked so that one can't e.g. unban an admin, thereby removing their admin status  def delUserlist(self, nick, status):    nick = nick.lower()    #must check status to avoid e.g. !delban removing a supreme admin    self.cur.execute("SELECT * FROM Userlist WHERE Nick=? AND Status=?", (nick, status,))        if self.cur.fetchone() == None:      print ">>No user exists at that status level<<"    else:      self.cur.execute("DELETE FROM Userlist WHERE Nick=?", (nick,))      self.db.commit()      # status a list of all statuses that are accepted, defaults to all  def listUserlist(self, status=[BANNED,ADMIN,SUPREME_ADMIN], verified=[True,False]):    statusList = ','.join([str(x) for x in status])    verifiedList = ','.join([str(int(x)) for x in verified])    self.cur.execute("SELECT Nick FROM Userlist WHERE Status IN (%s) AND Verified IN (%s)" % (statusList, verifiedList))    return [row[0] for row in self.cur]  # return the list of names      # an item is removed from the database and returned  def getItem(self):    self.cur.execute("SELECT * FROM Items ORDER BY RANDOM() LIMIT 1")    item = self.cur.fetchone()[0]    self.cur.execute("DELETE FROM Items WHERE Name=?", (item,))    self.db.commit()    return item          # add item  def addItem(self, item):    self.cur.execute("INSERT INTO Items VALUES(?)", (item,))    self.db.commit()          # returns the number of items in the database  def lenItem(self):    self.cur.execute("SELECT * FROM Items")    return len(self.cur.fetchall())    # add response  # if the response is not added, returns False  def addResponse(self, trigger, response):    self.cur.execute("SELECT * FROM AutoResponses WHERE Trigger=?", (trigger,))    if len(self.cur.fetchall()) < 5:  # a limit to how many responses there can be for a single trigger      self.cur.execute("INSERT INTO AutoResponses VALUES(?,?)", (trigger, response,))      self.db.commit()      return True    else:      return False    # checks responses for the trigger, returns the response if one is found, otherwise returns None  def checkResponse(self, trigger):    self.cur.execute("SELECT ROWID,Response FROM AutoResponses WHERE Trigger=? LIMIT 1", (trigger.lower(),))        row = self.cur.fetchone()    if row != None:      id, response = row      self.cur.execute("DELETE FROM AutoResponses WHERE ROWID=?", (id,))      self.db.commit()      return response          else: return None        # add/edit chan  def addChans(self, chan, status):    if status not in [True, False]:      print ">>Channel status(%s) not valid<<" % status      return        try:      self.cur.execute("INSERT INTO Chans VALUES(?,?)", (chan, int(status),))    except:      self.cur.execute("UPDATE Chans SET Status=? WHERE Chan=?", (int(status), chan,))    self.db.commit()      # del chan  def delChans(self, chan):    self.cur.execute("DELETE FROM Chans WHERE Chan=?", (chan,))    self.db.commit()        # list chans  # status a list of all statuses that are accepted, defaults to all  def listChans(self, status=[True,False]):    statusList = ','.join(str(int(x)) for x in status)    self.cur.execute("SELECT Chan FROM Chans WHERE Status IN (%s)" % statusList)    return [row[0] for row in self.cur]      # add messages  def addMessages(self, nick, channel, message):    self.cur.execute("INSERT INTO Messages VALUES(?,?,?)", (nick, channel, message,))    self.db.commit()        # check messages, returns a list of messages for the particular nick and channel  def checkMessages(self, nick, channel):    self.cur.execute("SELECT Message FROM Messages WHERE Nick=? AND Chan=?", (nick,channel,))        if self.cur != None:      response = [row[0] for row in self.cur]      self.cur.execute("DELETE FROM Messages WHERE Nick=? AND Chan=?", (nick,channel,))      self.db.commit()      return response    else: return None      # # edit info  # def editInfo(self, label, val):    # self.cur.execute("SELECT * FROM Info WHERE Label=?", (label,))        # if self.cur.fetchone() == None:      # print ">>No such field (%s) in the Info table<<" % label    # else:      # self.cur.execute("UPDATE Info SET Val=? WHERE Label=?", (val, label,))      # self.db.commit()              # # get info  # def getInfo(self, label):    # self.cur.execute("SELECT Val FROM Info WHERE Label=?", (label,))    # row = self.cur.fetchone()    # if row == None:      # print ">>No such field (%s) in the Info table<<" % label    # else:      # return row[0]              # add text to storage, updates if trigger already exists  def storeText(self, trigger, response):    # if the insert fails the trigger is already in the db    try:      self.cur.execute("INSERT INTO TextStorage VALUES(?,?)", (trigger.lower(), response,))    except:      self.cur.execute("UPDATE TextStorage SET Response=? WHERE Trigger=?", (response, trigger.lower(),))    self.db.commit()          # retrieve text from storage, returns None if trigger is not in the table  def getText(self, trigger):    self.cur.execute("SELECT Response FROM TextStorage WHERE Trigger=?", (trigger.lower(),))    response = self.cur.fetchone()    if response == None:      return None    else:      return response[0]              # return a list of triggers that match the search name, an empty list if none were found  def searchTextStorageNames(self, searchName):    self.cur.execute("SELECT Trigger FROM TextStorage WHERE Trigger LIKE ?", (searchName.lower(),))    return [row[0] for row in self.cur]        def incPostCount(self, nick):    self.cur.execute("SELECT PostCount FROM UserData WHERE Nick=?", (nick.lower(),))    result = self.cur.fetchone()    # if nick isn't in the table    if result == None:      self.cur.execute("INSERT INTO UserData VALUES(?,?)", (nick.lower(), 1,))    else:      count = result[0] + 1      self.cur.execute("UPDATE UserData SET PostCount=? WHERE Nick=?", (count, nick.lower(),))          self.db.commit()          def getPostCount(self, nick):    self.cur.execute("SELECT PostCount FROM UserData WHERE Nick=?", (nick.lower(),))    result = self.cur.fetchone()    if result == None:      return 0    else:      return result[0]      # adds a downvote to the quote of the given downvote, returns True is successful, an error message if not  def txtDownVote(self, id, nick):    self.cur.execute("SELECT Downvotes FROM UserQuotes WHERE ROWID=?", (id,))    result = self.cur.fetchone()    if result == None:      return "No .txt with that ID was found"        # if no downvotes yet registered for this quote    if result[0] == None or result[0] == '':      self.cur.execute("UPDATE UserQuotes SET Downvotes=? WHERE ROWID=?", (nick.lower(), id,))      self.db.commit()      return True    else:      nickList = result[0].split(',')            # if downvote is from a new nick      if nick.lower() not in nickList:        # if enough downvotes to reach threshold, delete quote        if len(nickList) == REQ_DOWNVOTES - 1:          self.cur.execute("DELETE FROM UserQuotes WHERE ROWID=?", (id,))          self.db.commit()        else:          nickList.append(nick.lower())          downvotes = ','.join(nickList)          self.cur.execute("UPDATE UserQuotes SET Downvotes=? WHERE ROWID=?", (downvotes, id,))          self.db.commit()        return True              else:        return "%s has already voted on this .txt" % nick      # add the nick and quote into the table, quote is list of strings, each being a line of the quote (max 3)  def txtSave(self, nick, quote):    modQuote = '\n'.join(quote[:3])        self.cur.execute("INSERT INTO UserQuotes (Nick, Txt) VALUES(?,?)", (nick, modQuote,))        self.db.commit()      # returns random [id,nick,quote,downvotes] corresponding to nick, None if not found  def txtRecallNick(self, nick):    self.cur.execute("SELECT ROWID,Nick,Txt,Downvotes FROM UserQuotes WHERE Nick=? COLLATE NOCASE ORDER BY RANDOM() LIMIT 1", (nick,))        result = self.cur.fetchone()    if result == None:      return None        id = result[0]    dbNick = result[1]    quote = result[2].split("\n")    if result[3]:      downvotes = result[3].split(',')    else:      downvotes = []        return (id,dbNick,quote,downvotes)      # returns [id,nick,quote,downvotes] corresponding to id, None if not found  def txtRecallId(self, id):    self.cur.execute("SELECT Nick,Txt,Downvotes FROM UserQuotes WHERE ROWID=?", (nick,))        result = self.cur.fetchone()    if result == None:      return None        nick = result[0]    quote = result[1].split("\n")    if result[2]:      downvotes = result[2].split(',')    else:      downvotes = []        return (id,nick,quote,downvotes)