import sqlite3 as sqliteimport sys, stringimport datetime#definesBANNED = 0ADMIN = 1SUPREME_ADMIN = 2REQ_DOWNVOTES = -5MAX_LOG_LINES = 2000SPECIAL_NICK = "1placeholder"class dbAccess(object):  def __init__(self, dbName):    self.db = sqlite.connect(dbName, detect_types=sqlite.PARSE_DECLTYPES)    self.cur = self.db.cursor()    self.prevTxtId = 1      def __del__(self):    self.db.close()      # add ban/admin/s admin, will update the row if the nick is already in the database  # returns False is no change was made, True otherwise  def addUserlist(self, nick, newStatus, verified=False):    if newStatus not in [BANNED, ADMIN, SUPREME_ADMIN]:      print ">>User status(%s) not valid<<" % newStatus      return    nick = nick.lower()        self.cur.execute("SELECT Status FROM Userlist WHERE Nick=?", (nick,))    oldStatus = self.cur.fetchone()    if oldStatus == None:      self.cur.execute("INSERT INTO Userlist VALUES(?,?,?)", (nick, newStatus, int(verified),))    #can't downgrade someone's status    elif oldStatus[0] < newStatus:      self.cur.execute("UPDATE Userlist SET Status=? WHERE Nick=?", (newStatus, nick,))    else:      return False          self.db.commit()    return True    # del ban/admin, status is checked so that one can't e.g. unban an admin, thereby removing their admin status  def delUserlist(self, nick, status):    nick = nick.lower()    #must check status to avoid e.g. !delban removing a supreme admin    self.cur.execute("SELECT * FROM Userlist WHERE Nick=? AND Status=?", (nick, status,))        if self.cur.fetchone() == None:      print ">>No user exists at that status level<<"    else:      self.cur.execute("DELETE FROM Userlist WHERE Nick=?", (nick,))      self.db.commit()      # status a list of all statuses that are accepted, defaults to all  def listUserlist(self, status=[BANNED,ADMIN,SUPREME_ADMIN], verified=[True,False]):    statusList = ','.join([str(x) for x in status])    verifiedList = ','.join([str(int(x)) for x in verified])    self.cur.execute("SELECT Nick FROM Userlist WHERE Status IN (%s) AND Verified IN (%s)" % (statusList, verifiedList))    return [row[0] for row in self.cur]  # return the list of names      # an item is removed from the database and returned  def getItem(self):    self.cur.execute("SELECT * FROM Items ORDER BY RANDOM() LIMIT 1")    item = self.cur.fetchone()[0]    self.cur.execute("DELETE FROM Items WHERE Name=?", (item,))    self.db.commit()    return item          # add item  def addItem(self, item):    self.cur.execute("INSERT INTO Items VALUES(?)", (item,))    self.db.commit()          # returns the number of items in the database  def lenItem(self):    self.cur.execute("SELECT * FROM Items")    return len(self.cur.fetchall())    # add response  # if the response is not added, returns False  def addResponse(self, trigger, response):    self.cur.execute("SELECT * FROM AutoResponses WHERE Trigger=?", (trigger,))    if len(self.cur.fetchall()) < 5:  # a limit to how many responses there can be for a single trigger      self.cur.execute("INSERT INTO AutoResponses VALUES(?,?)", (trigger, response,))      self.db.commit()      return True    else:      return False    # checks responses for the trigger, returns the response if one is found, otherwise returns None  def checkResponse(self, trigger):    self.cur.execute("SELECT ROWID,Response FROM AutoResponses WHERE Trigger=? LIMIT 1", (trigger.lower(),))        row = self.cur.fetchone()    if row != None:      id, response = row      self.cur.execute("DELETE FROM AutoResponses WHERE ROWID=?", (id,))      self.db.commit()      return response          else: return None        # add/edit chan  def addChans(self, chan, status):    if status not in [True, False]:      print ">>Channel status(%s) not valid<<" % status      return        try:      self.cur.execute("INSERT INTO Chans VALUES(?,?)", (chan, int(status),))    except:      self.cur.execute("UPDATE Chans SET Status=? WHERE Chan=?", (int(status), chan,))    self.db.commit()      # del chan  def delChans(self, chan):    self.cur.execute("DELETE FROM Chans WHERE Chan=?", (chan,))    self.db.commit()        # list chans  # status a list of all statuses that are accepted, defaults to all  def listChans(self, status=[True,False]):    statusList = ','.join(str(int(x)) for x in status)    self.cur.execute("SELECT Chan FROM Chans WHERE Status IN (%s)" % statusList)    return [row[0] for row in self.cur]      # add messages  def addMessages(self, nick, channel, message):    self.cur.execute("INSERT INTO Messages VALUES(?,?,?)", (nick, channel, message,))    self.db.commit()        # check messages, returns a list of messages for the particular nick and channel  def checkMessages(self, nick, channel):    self.cur.execute("SELECT Message FROM Messages WHERE Nick=? AND Chan=?", (nick,channel,))        if self.cur != None:      response = [row[0] for row in self.cur]      self.cur.execute("DELETE FROM Messages WHERE Nick=? AND Chan=?", (nick,channel,))      self.db.commit()      return response    else: return None              # add text to storage, updates if trigger already exists  def storeText(self, trigger, response):    # if the insert fails the trigger is already in the db    try:      self.cur.execute("INSERT INTO TextStorage VALUES(?,?)", (trigger.lower(), response,))    except:      self.cur.execute("UPDATE TextStorage SET Response=? WHERE Trigger=?", (response, trigger.lower(),))    self.db.commit()          # retrieve text from storage, returns None if trigger is not in the table  def getText(self, trigger):    self.cur.execute("SELECT Response FROM TextStorage WHERE Trigger=?", (trigger.lower(),))    response = self.cur.fetchone()    if response == None:      return None    else:      return response[0]              # return a list of triggers that match the search name, an empty list if none were found  def searchTextStorageNames(self, searchName):    self.cur.execute("SELECT Trigger FROM TextStorage WHERE Trigger LIKE ?", (searchName.lower(),))    return [row[0] for row in self.cur]        def incPostCount(self, nick):    self.cur.execute("INSERT OR IGNORE INTO UserData VALUES(?,?)", (nick.lower(), 0,))    self.cur.execute("UPDATE UserData SET PostCount = PostCount + 1 WHERE Nick=?", (nick.lower(),))          self.db.commit()          def getPostCount(self, nick):    self.cur.execute("SELECT PostCount FROM UserData WHERE Nick=?", (nick.lower(),))    result = self.cur.fetchone()    if result == None:      return 0    else:      return result[0]  def txtVote(self, id, nick, vote):    self.cur.execute("SELECT * FROM Quotes WHERE Id=?", (id,))    # if no quote by that id exists, exit    if self.cur.fetchone() == None:      return "No .txt with that ID was found"        self.cur.execute("SELECT Nick, Vote FROM QuoteVotes WHERE Quote_Id=?", (id,))    result = self.cur.fetchall()        # search results to see if that nick has already made a vote on that txt and add up current vote count    addEntry = True    prevVote = 0    voteTotal = 0    for row in result:      if row[0] == nick:        addEntry = False        prevVote = row[1]      voteTotal += row[1]                    # if new vote causes downvote limit to be reached, delete quote    if voteTotal - prevVote + vote <= REQ_DOWNVOTES:      deleteQuote(id)      return "Vote added/updated, quote deleted"    else:      # insert or update accordingly      if addEntry:        self.cur.execute("INSERT INTO QuoteVotes VALUES(?, ?, ?)", (nick, id, vote,))      else:        self.cur.execute("UPDATE QuoteVotes SET Vote=? WHERE Nick=? AND Quote_Id=?", (vote, nick, id,))              self.db.commit()      return "Vote added/updated"            # decays the rating of already downvoted quotes  # should be called very rarely due to number of db queries  def txtTimeVote(self):    # check the date on every quote in the database    self.cur.execute("SELECT Id, dateLastChecked FROM Quotes")        quoteResult = self.cur.fetchall()    for id, prevDate in quoteResult:      y,m,d = [int(x) for x in prevDate.split('-')]      # if more than two months has passed since the quote was evaluated      if (datetime.date.today() - datetime.date(y,m,d)).days > 60:        # add up it's votes        self.cur.execute("SELECT Quote_Id, Vote FROM QuoteVotes WHERE Quote_Id=?", (id,))                voteResult = self.cur.fetchall()        voteTotal = 0        for vote in voteResult:          voteTotal += vote[1]                  if voteTotal < 0 and voteTotal > REQ_DOWNVOTES + 1:          self.cur.execute("INSERT OR IGNORE INTO QuoteVotes VALUES(?,?,?)", (SPECIAL_NICK, id, -1))          self.cur.execute("UPDATE Quotevotes SET Vote = Vote - 1 WHERE Nick=? AND id=?", (SPECIAL_NICK, id,))          self.cur.execute("UPDATE Quote SET dateLastChecked=date('now')")          self.db.commit()        elif voteTotal <= REQ_DOWNVOTES + 1:          deleteQuote(id)                                def deleteQuote(id):    self.cur.execute("DELETE FROM QuoteVotes WHERE Quote_Id=?", (id,))    self.cur.execute("DELETE FROM Quotes WHERE Id=?", (id,))    self.db.commit()              def txtSave(self, nick, quote):    modQuote = '\n'.join(quote[:3])        self.cur.execute("INSERT INTO UserQuotes (Nick, Txt) VALUES(null, ?, ?, date('now'))", (nick, modQuote,))    self.db.commit()  # returns quote corresponding to nick, None if not found  def getTxtFromNick(self, nick):      # return the the lowest Id quote with an Id greater than the last returned quote Id    self.cur.execute("SELECT Id, Nick, Txt FROM Quotes WHERE lower(Nick) = ? AND Id > ? COLLATE NOCASE ORDER BY Id ASC LIMIT 1", (nick.lower(), self.prevTxtId,))    print "I'm here"+str(self.prevTxtId)    result = self.cur.fetchone()    if result == None:      print "I'm here now"+str(self.prevTxtId)      # if none were found greater than the last returned quote Id, return the lowest Id one      self.cur.execute("SELECT Id, Nick, Txt FROM Quotes WHERE lower(Nick) = ? COLLATE NOCASE ORDER BY Id ASC LIMIT 1", (nick.lower(),))      result = self.cur.fetchone()      if result == None:        return None    id = result[0]    dbNick = result[1]    quote = result[2].split("\n")    self.prevTxtId = id        return (id, dbNick, quote)  # returns quote corresponding to id, None if not found  def getTxtFromId(self, id):    self.cur.execute("SELECT Nick, Txt FROM UserQuotes WHERE Id=?", (id,))        result = self.cur.fetchone()    if result == None:      return None        nick = result[0]    quote = result[1].split("\n")        return (id, nick, quote)                def storeLog(self, nick, text, chan):    self.cur.execute("INSERT INTO Log (Nick, Message, Chan, Date) VALUES(?,?,?,date('now'))", (nick, text, chan,))      self.db.commit()      # return all (max 2000) lines ever said by nick in channel  def getLogs(self, nick='%', chan='%', lines=MAX_LOG_LINES):    self.cur.execute("SELECT Message FROM Log WHERE Nick LIKE ? AND Chan LIKE ? ORDER BY RANDOM() LIMIT ?", (nick, chan, lines,))        return [row[0] for row in self.cur]          